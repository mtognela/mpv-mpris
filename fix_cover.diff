diff --git a/.vscode/c_cpp_properties.json b/.vscode/c_cpp_properties.json
new file mode 100644
index 0000000..f103c36
--- /dev/null
+++ b/.vscode/c_cpp_properties.json
@@ -0,0 +1,19 @@
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "includePath": [
+                "${workspaceFolder}/**",
+                "/usr/include/",
+                "/usr/include/glib-2.0",
+                "/usr/lib/glib-2.0/include"
+            ],
+            "defines": [],
+            "compilerPath": "/usr/bin/clang",
+            "cStandard": "c17",
+            "cppStandard": "c++17",
+            "intelliSenseMode": "linux-clang-x64"
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..9e00bd3
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,8 @@
+{
+    "C_Cpp.errorSquiggles": "enabled",
+    "files.associations": {
+        "gio.h": "c",
+        "string.h": "c",
+        "avformat.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/mpris.c b/mpris.c
index ed02d93..defee63 100644
--- a/mpris.c
+++ b/mpris.c
@@ -6,7 +6,7 @@
 #include <string.h>
 
 
-
+// what the fuck is this xml?
 static const char *introspection_xml =
     "<node>\n"
     "  <interface name=\"org.mpris.MediaPlayer2\">\n"
@@ -68,6 +68,7 @@ static const char *introspection_xml =
     "  </interface>\n"
     "</node>\n";
 
+// maybe this is the UserData that changes doring the program 
 typedef struct UserData
 {
     mpv_handle *mpv;
@@ -80,6 +81,7 @@ typedef struct UserData
     guint player_interface_id;
     const char *status;
     const char *loop_status;
+    gboolean shuffle;
     GHashTable *changed_properties;
     GVariant *metadata;
     gboolean seek_expected;
@@ -285,80 +287,34 @@ static gchar* try_get_youtube_thumbnail(char *path)
     return out;
 }
 
-static gchar* get_cache_dir() {
-    gchar *cache_dir = g_build_filename(g_get_user_cache_dir(), "mpv-mpris", "coverart", NULL);
-    
-    if (g_mkdir_with_parents(cache_dir, 0755) < 0) {
-        g_warning("Failed to create cache directory: %s", g_strerror(errno));
-        g_free(cache_dir);
-        return NULL;
-    }
-    
-    return cache_dir;
-}
-
-static gchar* generate_cache_filename(const char *path) {
-    gchar *hash = g_compute_checksum_for_string(G_CHECKSUM_SHA256, path, -1);
-    gchar *filename = g_strconcat(hash, ".jpg", NULL);
-    g_free(hash);
-    return filename;
-}
-
-static gchar* extract_embedded_art(AVFormatContext *context, const char *media_path) {
+static gchar* extract_embedded_art(AVFormatContext *context) {
     AVPacket *packet = NULL;
-    gchar *cache_path = NULL;
-    gchar *uri = NULL;
-    
     for (unsigned int i = 0; i < context->nb_streams; i++) {
         if (context->streams[i]->disposition & AV_DISPOSITION_ATTACHED_PIC) {
             packet = &context->streams[i]->attached_pic;
-            break;
         }
     }
-    
     if (!packet) {
         return NULL;
     }
 
-    gchar *cache_dir = get_cache_dir();
-    if (!cache_dir) {
-        return NULL;
-    }
+    gchar *data = g_base64_encode(packet->data, packet->size);
+    gchar *img = g_strconcat("data:image/jpeg;base64,", data, NULL);
 
-    gchar *cache_filename = generate_cache_filename(media_path);
-    cache_path = g_build_filename(cache_dir, cache_filename, NULL);
-    g_free(cache_filename);
-    
-    if (!g_file_test(cache_path, G_FILE_TEST_EXISTS)) {
-        GError *error = NULL;
-        if (!g_file_set_contents(cache_path, (const gchar*)packet->data, 
-                                packet->size, &error)) {
-            g_warning("Failed to write cover art to cache: %s", error->message);
-            g_error_free(error);
-            g_free(cache_path);
-            g_free(cache_dir);
-            return NULL;
-        }
-    }
-
-    uri = g_filename_to_uri(cache_path, NULL, NULL);
-    
-    g_free(cache_path);
-    g_free(cache_dir);
-    return uri;
+    g_free(data);
+    return img;
 }
 
 static gchar* try_get_embedded_art(char *path)
 {
-    gchar *uri = NULL;
+    gchar *out = NULL;
     AVFormatContext *context = NULL;
-    
     if (!avformat_open_input(&context, path, NULL, NULL)) {
-        uri = extract_embedded_art(context, path);
+        out = extract_embedded_art(context);
         avformat_close_input(&context);
     }
 
-    return uri;
+    return out;
 }
 
 // cached last file path, owned by mpv
@@ -725,7 +681,7 @@ static GVariant *get_property_player(G_GNUC_UNUSED GDBusConnection *connection,
 
     } else if (g_strcmp0(property_name, "Shuffle") == 0) {
         int shuffle;
-        mpv_get_property(ud->mpv, "playlist-shuffle", MPV_FORMAT_FLAG, &shuffle);
+        mpv_get_property(ud->mpv, "shuffle", MPV_FORMAT_FLAG, &shuffle);
         ret = g_variant_new_boolean(shuffle);
 
     } else if (g_strcmp0(property_name, "Metadata") == 0) {
@@ -815,7 +771,14 @@ static gboolean set_property_player(G_GNUC_UNUSED GDBusConnection *connection,
 
     } else if (g_strcmp0(property_name, "Shuffle") == 0) {
         int shuffle = g_variant_get_boolean(value);
-        mpv_set_property(ud->mpv, "playlist-shuffle", MPV_FORMAT_FLAG, &shuffle);
+        if (shuffle && !ud->shuffle) {
+            const char *cmd[] = {"playlist-shuffle", NULL};
+            mpv_command_async(ud->mpv, 0, cmd);
+        } else if (!shuffle && ud->shuffle) {
+            const char *cmd[] = {"playlist-unshuffle", NULL};
+            mpv_command_async(ud->mpv, 0, cmd);
+        }
+        mpv_set_property(ud->mpv, "shuffle", MPV_FORMAT_FLAG, &shuffle);
 
     } else if (g_strcmp0(property_name, "Volume") == 0) {
         double volume = g_variant_get_double(value);
@@ -1034,6 +997,12 @@ static void handle_property_change(const char *name, void *data, UserData *ud)
         prop_name = "LoopStatus";
         prop_value = g_variant_new_string(ud->loop_status);
 
+    } else if (g_strcmp0(name, "shuffle") == 0) {
+        int shuffle = *(int*)data;
+        ud->shuffle = shuffle;
+        prop_name = "Shuffle";
+        prop_value = g_variant_new_boolean(shuffle);
+
     } else if (g_strcmp0(name, "fullscreen") == 0) {
         gboolean *status = data;
         prop_name = "Fullscreen";
@@ -1128,6 +1097,7 @@ int mpv_open_cplugin(mpv_handle *mpv)
     ud.seek_expected = FALSE;
     ud.idle = FALSE;
     ud.paused = FALSE;
+    ud.shuffle = FALSE;
 
     g_main_context_push_thread_default(ctx);
     ud.bus_id = g_bus_own_name(G_BUS_TYPE_SESSION,
@@ -1148,6 +1118,7 @@ int mpv_open_cplugin(mpv_handle *mpv)
     mpv_observe_property(mpv, 0, "loop-file", MPV_FORMAT_STRING);
     mpv_observe_property(mpv, 0, "loop-playlist", MPV_FORMAT_STRING);
     mpv_observe_property(mpv, 0, "duration", MPV_FORMAT_INT64);
+    mpv_observe_property(mpv, 0, "shuffle", MPV_FORMAT_FLAG);
     mpv_observe_property(mpv, 0, "fullscreen", MPV_FORMAT_FLAG);
 
     // Run callback whenever there are events
